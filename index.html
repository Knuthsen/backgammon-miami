<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Miami Vice Backgammon - Final Edition</title>
    <style>
        :root {
            --player-1: rgb(235, 149, 228); 
            --player-2: rgb(96, 207, 210);  
            --bg-dark: rgba(10, 10, 30, 0.7);
        }

body, html {
    margin: 0; padding: 0; width: 100%; height: 100%;
    background: #050510; /* Neutraler dunkler Hintergrund außen */
    font-family: 'Segoe UI', sans-serif;
    overflow: hidden; display: flex; justify-content: center; align-items: center;
}
        #turn-indicator {
            position: absolute; top: env(safe-area-inset-top, 15px); 
            left: 50%; transform: translateX(-50%);
            color: white; font-weight: bold; text-transform: uppercase; letter-spacing: 2px;
            text-shadow: 0 0 15px var(--player-2); z-index: 100; text-align: center;
        }

#game-container {
    width: 92vw; 
    height: 82vh; 
    max-width: 1100px;
    margin-left: env(safe-area-inset-left);
    margin-right: env(safe-area-inset-right);
    
    /* Bild direkt im Board-Container */
    background-image: linear-gradient(rgba(10, 10, 30, 0.6), rgba(10, 10, 30, 0.6)), url('1.jpeg');
    background-size: 100% 100%; /* Zwingt das Bild exakt in die Box */
    background-position: center;
    
    border: 3px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 0 50px rgba(0, 0, 0, 0.7);
    display: flex; position: relative;
    backdrop-filter: blur(5px); 
    border-radius: 12px;
}

        /* Anpassung für flache Querformate (iPhone) */
        @media (orientation: landscape) and (max-height: 500px) {
            #game-container {
                height: 88vh;
            }
            #turn-indicator {
                top: 5px;
                font-size: 0.8rem;
            }
        }

        .board-half { flex: 1; display: flex; flex-direction: column; z-index: 1; }
        .quadrant { flex: 1; display: flex; justify-content: space-around; position: relative; }

        .point { width: 14%; height: 100%; position: relative; display: flex; justify-content: center; cursor: pointer; z-index: 5; }

        .triangle-shape { position: absolute; width: 100%; height: 85%; z-index: 1; opacity: 1; pointer-events: none; }
        .top-quadrant .triangle-shape { clip-path: polygon(0 0, 100% 0, 50% 100%); top: 0; }
        .bottom-quadrant .triangle-shape { clip-path: polygon(50% 0, 0 100%, 100% 100%); bottom: 0; }

        .color-pink { background: linear-gradient(to bottom, var(--player-1), rgba(235, 149, 228, 0.2)); }
        .color-turquoise { background: linear-gradient(to bottom, var(--player-2), rgba(96, 207, 210, 0.2)); }
        .bottom-quadrant .color-pink { background: linear-gradient(to top, var(--player-1), rgba(235, 149, 228, 0.2)); }
        .bottom-quadrant .color-turquoise { background: linear-gradient(to top, var(--player-2), rgba(96, 207, 210, 0.2)); }

        .checker-stack { position: absolute; inset: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; pointer-events: none; z-index: 10; }
        .bottom-quadrant .checker-stack { flex-direction: column-reverse; }
        .edge-spacer { height: 15px; width: 100%; flex-shrink: 0; }

        .checker {
            width: clamp(16px, 3.8vw, 36px); height: clamp(16px, 3.8vw, 36px);
            border-radius: 50%; margin: -6px 0; 
            box-shadow: 0 4px 10px rgba(0,0,0,0.6); flex-shrink: 0; position: relative;
        }
        .checker.selected { outline: 3px solid white; box-shadow: 0 0 20px white; z-index: 50; transform: scale(1.1); }
        
        .white-checker { background: radial-gradient(circle at 35% 35%, #fff, #bbb); border: 1px solid #fff; }
        .black-checker { background: radial-gradient(circle at 35% 35%, #444, #000); border: 1px solid #333; }

        #bar { 
            width: 70px; 
            background: rgba(255, 255, 255, 0.05); 
            border-left: 2px solid rgba(255, 255, 255, 0.1); 
            border-right: 2px solid rgba(255, 255, 255, 0.1); 
            z-index: 2; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center;
            gap: 20px;
        }

        .bar-section { 
            width: 100%; 
            display: flex; 
            align-items: center; 
            cursor: pointer;
            min-height: 150px;
        }
        #bar-white { flex-direction: column-reverse; justify-content: flex-start; }
        #bar-black { flex-direction: column; justify-content: flex-start; }
        .bar-section .checker { margin: 2px 0; }

        #dice-container { display: flex; flex-direction: column; gap: 15px; cursor: pointer; }
        .die { width: 35px; height: 35px; background: white; border-radius: 6px; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); padding: 5px; box-sizing: border-box; }
        .dot { background: #1a1a1a; border-radius: 50%; width: 5px; height: 5px; align-self: center; justify-self: center; }
        .die.rolling { animation: roll 0.4s infinite linear; }
        @keyframes roll { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #off-board {
            width: 40px; background: rgba(0,0,0,0.2); display: flex; flex-direction: column; justify-content: space-between; padding: 10px 0;
        }
        .off-section { flex: 1; display: flex; flex-direction: column; align-items: center; gap: 2px; }
        .off-checker { width: 30px; height: 10px; border-radius: 2px; border: 1px solid rgba(255,255,255,0.3); }
    </style>
</head>
<body>

    <div id="turn-indicator">Player: <span id="p-name" style="color: var(--player-1)">PINK</span><br><small id="p-moves">Click dice to roll</small></div>

    <div id="game-container">
        <div class="board-half">
            <div class="quadrant top-quadrant" id="q-upper-left"></div>
            <div class="quadrant bottom-quadrant" id="q-lower-left"></div>
        </div>
        
        <div id="bar">
            <div id="bar-white" class="bar-section" onclick="handleBarClick('white')"></div>
            <div id="dice-container" onclick="rollDice()">
                <div id="die1" class="die"></div>
                <div id="die2" class="die"></div>
            </div>
            <div id="bar-black" class="bar-section" onclick="handleBarClick('black')"></div>
        </div>

        <div class="board-half">
            <div class="quadrant top-quadrant" id="q-upper-right"></div>
            <div class="quadrant bottom-quadrant" id="q-lower-right"></div>
        </div>

        <div id="off-board">
            <div id="off-black" class="off-section"></div>
            <div id="off-white" class="off-section"></div>
        </div>
    </div>

    <script>
        let gameState = {
            points: {
                1: { count: 2, color: 'white' }, 6: { count: 5, color: 'black' }, 8: { count: 3, color: 'black' },
                12: { count: 5, color: 'white' }, 13: { count: 5, color: 'black' }, 17: { count: 3, color: 'white' },
                19: { count: 5, color: 'white' }, 24: { count: 2, color: 'black' }
            },
            bar: { white: 0, black: 0 },
            off: { white: 0, black: 0 },
            currentPlayer: 'white',
            currentRoll: [],
            selectedPoint: null,
            diceRolled: false,
            isAnimating: false
        };

        const patterns = { 1:[4], 2:[0,8], 3:[0,4,8], 4:[0,2,6,8], 5:[0,2,4,6,8], 6:[0,2,3,5,6,8] };

        function drawDie(id, val) {
            const el = document.getElementById(id); el.innerHTML = '';
            if(!val) return;
            patterns[val].forEach(p => {
                const d = document.createElement('div'); d.className='dot';
                d.style.gridColumn = (p % 3) + 1; d.style.gridRow = Math.floor(p / 3) + 1;
                el.appendChild(d);
            });
        }

        function rollDice() {
            if (gameState.diceRolled || gameState.isAnimating) return;
            const d1 = Math.floor(Math.random() * 6) + 1;
            const d2 = Math.floor(Math.random() * 6) + 1;
            document.querySelectorAll('.die').forEach(d => d.classList.add('rolling'));
            
            setTimeout(() => {
                document.querySelectorAll('.die').forEach(d => d.classList.remove('rolling'));
                drawDie('die1', d1); drawDie('die2', d2);
                gameState.currentRoll = (d1 === d2) ? [d1, d1, d1, d1] : [d1, d2];
                gameState.diceRolled = true;
                if (!canMoveAnywhere()) {
                    document.getElementById('p-moves').innerText = "No moves possible!";
                    setTimeout(endTurn, 1500);
                } else { updateUI(); }
            }, 600);
        }

        function canMoveAnywhere() {
            const rolls = [...new Set(gameState.currentRoll)];
            if (gameState.bar[gameState.currentPlayer] > 0) {
                return rolls.some(r => isMoveLegal('bar', gameState.currentPlayer === 'white' ? 25 - r : r, r));
            }
            const canOff = isHomeReady();
            for (let p in gameState.points) {
                if (gameState.points[p].color === gameState.currentPlayer) {
                    if (rolls.some(r => {
                        const to = gameState.currentPlayer === 'white' ? p - r : parseInt(p) + r;
                        if (canOff && (to < 1 || to > 24)) return true;
                        return isMoveLegal(p, to, r);
                    })) return true;
                }
            }
            return false;
        }

        function isHomeReady() {
            if (gameState.bar[gameState.currentPlayer] > 0) return false;
            for (let p in gameState.points) {
                if (gameState.points[p].color === gameState.currentPlayer) {
                    if (gameState.currentPlayer === 'white' && p > 6) return false;
                    if (gameState.currentPlayer === 'black' && p < 19) return false;
                }
            }
            return true;
        }

        function isMoveLegal(from, to, dist) {
            if (to < 1 || to > 24) {
                if (!isHomeReady()) return false;
                if (gameState.currentPlayer === 'white') {
                    if (to === 0) return true;
                    if (to < 0) {
                        for (let i = 6; i > from; i--) if (gameState.points[i]?.color === 'white') return false;
                        return true;
                    }
                } else {
                    if (to === 25) return true;
                    if (to > 25) {
                        for (let i = 19; i < from; i++) if (gameState.points[i]?.color === 'black') return false;
                        return true;
                    }
                }
                return false;
            }
            const target = gameState.points[to];
            return !target || target.color === gameState.currentPlayer || target.count === 1;
        }

        function handleBarClick(color) {
            if (gameState.currentPlayer === color && gameState.bar[color] > 0 && gameState.diceRolled) {
                gameState.selectedPoint = 'bar'; renderBoard();
            }
        }

        async function handlePointClick(num) {
            if (!gameState.diceRolled || gameState.isAnimating) return;

            if (gameState.selectedPoint === null) {
                if (gameState.bar[gameState.currentPlayer] > 0) return;
                if (gameState.points[num]?.color === gameState.currentPlayer) {
                    gameState.selectedPoint = num; 
                    renderBoard();
                }
            } 
            else {
                const from = gameState.selectedPoint;
                if (from === num) {
                    gameState.selectedPoint = null;
                    renderBoard();
                    return;
                }

                const dists = gameState.currentRoll.sort((a,b) => a-b);
                let appliedDist = null;

                for (let d of dists) {
                    const to = (from === 'bar') 
                        ? (gameState.currentPlayer === 'white' ? 25 - d : d) 
                        : (gameState.currentPlayer === 'white' ? from - d : parseInt(from) + d);
                    
                    if (to === num && isMoveLegal(from, to, d)) { 
                        appliedDist = d; 
                        break; 
                    }
                }
                
                if (!appliedDist && isHomeReady()) {
                    for (let d of dists) {
                        const to = gameState.currentPlayer === 'white' ? from - d : parseInt(from) + d;
                        if ((gameState.currentPlayer === 'white' && to <= 0) || (gameState.currentPlayer === 'black' && to >= 25)) {
                            if (isMoveLegal(from, to, d)) { appliedDist = d; break; }
                        }
                    }
                }

                if (appliedDist) {
                    const savedFrom = from;
                    gameState.selectedPoint = null; 
                    const to = (savedFrom === 'bar') 
                        ? (gameState.currentPlayer === 'white' ? 25 - appliedDist : appliedDist) 
                        : (gameState.currentPlayer === 'white' ? savedFrom - appliedDist : parseInt(savedFrom) + appliedDist);
                    await animateAndMove(savedFrom, to, appliedDist);
                } else {
                    if (gameState.points[num]?.color === gameState.currentPlayer) {
                        gameState.selectedPoint = num;
                    } else {
                        gameState.selectedPoint = null;
                    }
                    renderBoard();
                }
            }
        }

        async function animateAndMove(from, to, dist) {
            gameState.isAnimating = true;
            let startRect;
            if (from === 'bar') {
                startRect = document.getElementById(`bar-${gameState.currentPlayer}`).lastElementChild.getBoundingClientRect();
            } else {
                startRect = document.querySelector(`[data-point="${from}"] .checker-stack`).lastElementChild.getBoundingClientRect();
            }

            executeMoveLogic(from, to, dist);
            renderBoard();
            
            let targetChecker;
            if (to < 1 || to > 24) {
                targetChecker = document.getElementById(`off-${gameState.currentPlayer}`).lastElementChild;
            } else {
                targetChecker = document.querySelector(`[data-point="${to}"] .checker-stack`).lastElementChild;
            }
            const endRect = targetChecker.getBoundingClientRect();

            targetChecker.animate([
                { transform: `translate(${startRect.left - endRect.left}px, ${startRect.top - endRect.top}px)` },
                { transform: 'translate(0, 0)' }
            ], { duration: 300, easing: 'ease-out' }).onfinish = () => {
                gameState.isAnimating = false;
                gameState.selectedPoint = null;
                if (gameState.currentRoll.length === 0 || !canMoveAnywhere()) { setTimeout(endTurn, 800); }
                else { updateUI(); }
            };
        }

        function executeMoveLogic(from, to, dist) {
            if (from === 'bar') gameState.bar[gameState.currentPlayer]--;
            else {
                gameState.points[from].count--;
                if (gameState.points[from].count === 0) delete gameState.points[from];
            }

            if (to < 1 || to > 24) {
                gameState.off[gameState.currentPlayer]++;
            } else {
                if (gameState.points[to] && gameState.points[to].color !== gameState.currentPlayer) {
                    gameState.bar[gameState.currentPlayer === 'white' ? 'black' : 'white']++;
                    gameState.points[to] = { count: 1, color: gameState.currentPlayer };
                } else {
                    if (!gameState.points[to]) gameState.points[to] = { count: 0, color: gameState.currentPlayer };
                    gameState.points[to].count++;
                }
            }
            gameState.currentRoll.splice(gameState.currentRoll.indexOf(dist), 1);
        }

        function endTurn() {
            if (gameState.off.white === 15 || gameState.off.black === 15) {
                alert("GAME OVER! " + (gameState.off.white === 15 ? "PINK" : "TURQUOISE") + " WINS!");
                location.reload();
                return;
            }
            gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
            gameState.diceRolled = false;
            gameState.currentRoll = [];
            gameState.selectedPoint = null;
            renderBoard();
            updateUI();
        }

        function updateUI() {
            const isW = gameState.currentPlayer === 'white';
            document.getElementById('p-name').innerText = isW ? 'PINK' : 'TURQUOISE';
            document.getElementById('p-name').style.color = isW ? 'var(--player-1)' : 'var(--player-2)';
            document.getElementById('p-moves').innerText = gameState.diceRolled ? `Moves: ${gameState.currentRoll.join(', ')}` : "Roll the dice";
            renderBar('white'); renderBar('black');
            renderOff();
        }

        function renderBar(color) {
            const el = document.getElementById(`bar-${color}`); el.innerHTML = '';
            for (let i = 0; i < gameState.bar[color]; i++) {
                const c = document.createElement('div'); c.className = `checker ${color}-checker`;
                if (gameState.selectedPoint === 'bar' && gameState.currentPlayer === color && i === gameState.bar[color]-1) c.classList.add('selected');
                el.appendChild(c);
            }
        }

        function renderOff() {
            ['white', 'black'].forEach(c => {
                const el = document.getElementById(`off-${c}`); el.innerHTML = '';
                for (let i = 0; i < gameState.off[c]; i++) {
                    const ch = document.createElement('div'); ch.className = 'off-checker';
                    ch.style.backgroundColor = c === 'white' ? 'var(--player-1)' : 'var(--player-2)';
                    el.appendChild(ch);
                }
            });
        }

        function renderBoard() {
            const layout = [
                { id: 'q-lower-right', range: [6, 5, 4, 3, 2, 1] }, { id: 'q-lower-left',  range: [12, 11, 10, 9, 8, 7] },
                { id: 'q-upper-left',  range: [13, 14, 15, 16, 17, 18] }, { id: 'q-upper-right', range: [19, 20, 21, 22, 23, 24] }
            ];
            layout.forEach(q => {
                const el = document.getElementById(q.id); el.innerHTML = '';
                q.range.forEach(num => {
                    const p = document.createElement('div'); p.className = 'point'; p.setAttribute('data-point', num);
                    p.onclick = () => handlePointClick(num);
                    const tri = document.createElement('div'); tri.className = `triangle-shape ${num % 2 === 0 ? 'color-turquoise' : 'color-pink'}`;
                    const stack = document.createElement('div'); stack.className = 'checker-stack';
                    stack.appendChild(document.createElement('div')).className = 'edge-spacer';
                    if (gameState.points[num]) {
                        for (let i = 0; i < gameState.points[num].count; i++) {
                            const c = document.createElement('div'); c.className = `checker ${gameState.points[num].color}-checker`;
                            if (gameState.selectedPoint === num && i === gameState.points[num].count - 1) c.classList.add('selected');
                            stack.appendChild(c);
                        }
                    }
                    p.appendChild(tri); p.appendChild(stack); el.appendChild(p);
                });
            });
            renderBar('white'); renderBar('black'); renderOff();
        }

        renderBoard();
        drawDie('die1', 1); drawDie('die2', 2);
    </script>
</body>
</html>