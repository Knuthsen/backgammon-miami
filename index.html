<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Miami Vice Backgammon - Final Edition</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="icon.png">
    <style>
        :root {
            --player-1: rgb(235, 149, 228); 
            --player-2: rgb(96, 207, 210);  
            --bg-dark: rgba(10, 10, 30, 0.7);
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background: #050510;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden; display: flex; justify-content: center; align-items: center;
        }

        #turn-indicator {
            position: absolute; top: env(safe-area-inset-top, 15px); 
            left: 50%; transform: translateX(-50%);
            color: white; font-weight: bold; text-transform: uppercase; letter-spacing: 2px;
            text-shadow: 0 0 15px var(--player-2); z-index: 100; text-align: center;
        }

        #game-container {
            width: 92vw; height: 82vh; max-width: 1100px;
            margin-left: env(safe-area-inset-left); margin-right: env(safe-area-inset-right);
            background-image: linear-gradient(rgba(10, 10, 30, 0.6), rgba(10, 10, 30, 0.6)), url('1.jpeg');
            background-size: 100% 100%; background-position: center;
            border: 3px solid rgba(255, 255, 255, 0.2); box-shadow: 0 0 50px rgba(0, 0, 0, 0.7);
            display: flex; position: relative; backdrop-filter: blur(5px); border-radius: 12px;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            #game-container { height: 88vh; }
            #turn-indicator { top: 5px; font-size: 0.8rem; }
        }

        .board-half { flex: 1; display: flex; flex-direction: column; z-index: 1; }
        .quadrant { flex: 1; display: flex; justify-content: space-around; position: relative; }
        .point { width: 14%; height: 100%; position: relative; display: flex; justify-content: center; cursor: pointer; z-index: 5; }

        .triangle-shape { position: absolute; width: 100%; height: 85%; z-index: 1; opacity: 1; pointer-events: none; }
        .top-quadrant .triangle-shape { clip-path: polygon(0 0, 100% 0, 50% 100%); top: 0; }
        .bottom-quadrant .triangle-shape { clip-path: polygon(50% 0, 0 100%, 100% 100%); bottom: 0; }

        .color-pink { background: linear-gradient(to bottom, var(--player-1), rgba(235, 149, 228, 0.2)); }
        .color-turquoise { background: linear-gradient(to bottom, var(--player-2), rgba(96, 207, 210, 0.2)); }
        .bottom-quadrant .color-pink { background: linear-gradient(to top, var(--player-1), rgba(235, 149, 228, 0.2)); }
        .bottom-quadrant .color-turquoise { background: linear-gradient(to top, var(--player-2), rgba(96, 207, 210, 0.2)); }

        .checker-stack { position: absolute; inset: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; pointer-events: none; z-index: 10; }
        .bottom-quadrant .checker-stack { flex-direction: column-reverse; }
        .edge-spacer { height: 15px; width: 100%; flex-shrink: 0; }

        .checker {
            width: clamp(16px, 3.8vw, 36px); height: clamp(16px, 3.8vw, 36px);
            border-radius: 50%; margin: -6px 0; 
            box-shadow: 0 4px 10px rgba(0,0,0,0.6); flex-shrink: 0; position: relative;
        }
        .checker.selected { outline: 3px solid white; box-shadow: 0 0 20px white; z-index: 50; transform: scale(1.1); }
        .white-checker { background: radial-gradient(circle at 35% 35%, #fff, #bbb); border: 1px solid #fff; }
        .black-checker { background: radial-gradient(circle at 35% 35%, #444, #000); border: 1px solid #333; }

        #bar { width: 70px; background: rgba(255, 255, 255, 0.05); border-left: 2px solid rgba(255, 255, 255, 0.1); border-right: 2px solid rgba(255, 255, 255, 0.1); z-index: 2; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 20px; }
        .bar-section { width: 100%; display: flex; align-items: center; cursor: pointer; min-height: 150px; }
        #bar-white { flex-direction: column-reverse; justify-content: flex-start; }
        #bar-black { flex-direction: column; justify-content: flex-start; }

        #dice-container { display: flex; flex-direction: column; gap: 15px; cursor: pointer; }
        .die { width: 35px; height: 35px; background: white; border-radius: 6px; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); padding: 5px; box-sizing: border-box; }
        .dot { background: #1a1a1a; border-radius: 50%; width: 5px; height: 5px; align-self: center; justify-self: center; }
        .die.rolling { animation: roll 0.4s infinite linear; }
        @keyframes roll { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #off-board { width: 40px; background: rgba(0,0,0,0.2); display: flex; flex-direction: column; justify-content: space-between; padding: 10px 0; }
        .off-section { flex: 1; display: flex; flex-direction: column; align-items: center; gap: 2px; }
        .off-checker { width: 30px; height: 10px; border-radius: 2px; border: 1px solid rgba(255,255,255,0.3); }
    </style>
</head>
<body>

<div id="turn-indicator">Player: <span id="p-name" style="color: var(--player-1)">PINKY</span><br><small id="p-moves">Click dice to roll</small></div>

    <div id="game-container">
        <div class="board-half">
            <div class="quadrant top-quadrant" id="q-upper-left"></div>
            <div class="quadrant bottom-quadrant" id="q-lower-left"></div>
        </div>
        
        <div id="bar">
            <div id="bar-white" class="bar-section" onclick="handleBarClick('white')"></div>
            <div id="dice-container" onclick="rollDice()">
                <div id="die1" class="die"></div>
                <div id="die2" class="die"></div>
            </div>
            <div id="bar-black" class="bar-section" onclick="handleBarClick('black')"></div>
        </div>

        <div class="board-half">
            <div class="quadrant top-quadrant" id="q-upper-right"></div>
            <div class="quadrant bottom-quadrant" id="q-lower-right"></div>
        </div>

        <div id="off-board">
            <div id="off-black" class="off-section"></div>
            <div id="off-white" class="off-section"></div>
        </div>
    </div>

    <script>
        let gameState = {
            points: {
                1: { count: 2, color: 'black' }, 12: { count: 5, color: 'black' }, 17: { count: 3, color: 'black' }, 19: { count: 5, color: 'black' },
                6: { count: 5, color: 'white' }, 8: { count: 3, color: 'white' }, 13: { count: 5, color: 'white' }, 24: { count: 2, color: 'white' }
            },
            bar: { white: 0, black: 0 }, off: { white: 0, black: 0 },
            currentPlayer: 'white', currentRoll: [], selectedPoint: null,
            diceRolled: false, isAnimating: false
        };

        const patterns = { 1:[4], 2:[0,8], 3:[0,4,8], 4:[0,2,6,8], 5:[0,2,4,6,8], 6:[0,2,3,5,6,8] };

        function drawDie(id, val) {
            const el = document.getElementById(id); el.innerHTML = '';
            if(!val) return;
            patterns[val].forEach(p => {
                const d = document.createElement('div'); d.className='dot';
                d.style.gridColumn = (p % 3) + 1; d.style.gridRow = Math.floor(p / 3) + 1;
                el.appendChild(d);
            });
        }

        function rollDice() {
            if (gameState.diceRolled || gameState.isAnimating) return;
            const d1 = Math.floor(Math.random() * 6) + 1;
            const d2 = Math.floor(Math.random() * 6) + 1;
            document.querySelectorAll('.die').forEach(d => d.classList.add('rolling'));
            setTimeout(() => {
                document.querySelectorAll('.die').forEach(d => d.classList.remove('rolling'));
                drawDie('die1', d1); drawDie('die2', d2);
                gameState.currentRoll = (d1 === d2) ? [d1, d1, d1, d1] : [d1, d2];
                gameState.diceRolled = true;
                if (!canMoveAnywhere()) {
                    document.getElementById('p-moves').innerText = "NO MOVES POSSIBLE!";
                    setTimeout(endTurn, 1500);
                } else { updateUI(); if(gameState.currentPlayer === 'black') setTimeout(makeAIMove, 1000); }
            }, 600);
        }

        function canMoveAnywhere() {
            if (!gameState.currentRoll || gameState.currentRoll.length === 0) return false;
            const rolls = [...new Set(gameState.currentRoll)];
            const player = gameState.currentPlayer;
            if (gameState.bar[player] > 0) return rolls.some(r => isMoveLegal('bar', player === 'white' ? 25 - r : r, r));
            for (let p in gameState.points) {
                if (gameState.points[p].color === player) {
                    if (rolls.some(r => {
                        const to = player === 'white' ? p - r : parseInt(p) + r;
                        return isMoveLegal(p, to, r);
                    })) return true;
                }
            }
            return false;
        }

        function isHomeReady() {
            if (gameState.bar[gameState.currentPlayer] > 0) return false;
            for (let p in gameState.points) if (gameState.points[p].color === gameState.currentPlayer && (gameState.currentPlayer === 'white' ? p > 6 : p < 19)) return false;
            return true;
        }

        function isMoveLegal(from, to, dist) {
            if (to < 1 || to > 24) {
                if (!isHomeReady()) return false;
                if (gameState.currentPlayer === 'white') {
                    if (to === 0) return true;
                    if (to < 0) { for (let i = 6; i > from; i--) if (gameState.points[i]?.color === 'white') return false; return true; }
                } else {
                    if (to === 25) return true;
                    if (to > 25) { for (let i = 19; i < from; i++) if (gameState.points[i]?.color === 'black') return false; return true; }
                }
                return false;
            }
            const target = gameState.points[to];
            return !target || target.color === gameState.currentPlayer || target.count === 1;
        }

        function handleBarClick(color) {
            if (gameState.currentPlayer === color && gameState.bar[color] > 0 && gameState.diceRolled) {
                gameState.selectedPoint = 'bar'; renderBoard();
            }
        }

        async function handlePointClick(num) {
            if (!gameState.diceRolled || gameState.isAnimating || gameState.currentPlayer === 'black') return;
            if (gameState.selectedPoint === num && isHomeReady()) {
                const dists = gameState.currentRoll.sort((a, b) => a - b);
                for (let d of dists) {
                    const to = gameState.currentPlayer === 'white' ? num - d : parseInt(num) + d;
                    if (isMoveLegal(num, to, d) && (to < 1 || to > 24)) { await animateAndMove(num, to < 1 ? 0 : 25, d); return; }
                }
            }
            if (gameState.selectedPoint === null) {
                if (gameState.bar[gameState.currentPlayer] > 0) return;
                if (gameState.points[num]?.color === gameState.currentPlayer) { gameState.selectedPoint = num; renderBoard(); }
            } else {
                const from = gameState.selectedPoint;
                if (from === num) { gameState.selectedPoint = null; renderBoard(); return; }
                const dists = gameState.currentRoll.sort((a,b) => a-b);
                for (let d of dists) {
                    const to = (from === 'bar') ? (gameState.currentPlayer === 'white' ? 25 - d : d) : (gameState.currentPlayer === 'white' ? from - d : parseInt(from) + d);
                    if (to === num && isMoveLegal(from, to, d)) { await animateAndMove(from, to, d); return; }
                }
                if (gameState.points[num]?.color === gameState.currentPlayer) { gameState.selectedPoint = num; renderBoard(); }
                else { gameState.selectedPoint = null; renderBoard(); }
            }
        }

        async function animateAndMove(from, to, dist) {
            gameState.isAnimating = true;
            let movingChecker;
            if (from === 'bar') movingChecker = document.getElementById(`bar-${gameState.currentPlayer}`).lastElementChild;
            else movingChecker = document.querySelector(`[data-point="${from}"] .checker-stack`).lastElementChild;
            
            const startRect = movingChecker.getBoundingClientRect();
            gameState.selectedPoint = null;

            // Check if it's a "Hit"
            let hitOccurred = false;
            let hitRect = null;
            if (to >= 1 && to <= 24 && gameState.points[to] && gameState.points[to].color !== gameState.currentPlayer) {
                hitOccurred = true;
                hitRect = document.querySelector(`[data-point="${to}"] .checker-stack`).lastElementChild.getBoundingClientRect();
            }

            executeMoveLogic(from, to, dist);
            renderBoard();

            // Animate main checker
            let targetChecker = (to < 1 || to > 24) ? document.getElementById(`off-${gameState.currentPlayer}`).lastElementChild : document.querySelector(`[data-point="${to}"] .checker-stack`).lastElementChild;
            const endRect = targetChecker.getBoundingClientRect();
            
            const mainAnim = targetChecker.animate([
                { transform: `translate(${startRect.left - endRect.left}px, ${startRect.top - endRect.top}px)` },
                { transform: 'translate(0, 0)' }
            ], { duration: 300, easing: 'ease-out' });

            // Animate hit checker to bar
            if (hitOccurred) {
                const otherColor = gameState.currentPlayer === 'white' ? 'black' : 'white';
                const barTarget = document.getElementById(`bar-${otherColor}`).lastElementChild;
                const barRect = barTarget.getBoundingClientRect();
                barTarget.animate([
                    { transform: `translate(${hitRect.left - barRect.left}px, ${hitRect.top - barRect.top}px)` },
                    { transform: 'translate(0, 0)' }
                ], { duration: 400, easing: 'ease-in-out' });
            }

            mainAnim.onfinish = () => {
                gameState.isAnimating = false;
                if (gameState.currentRoll.length === 0 || !canMoveAnywhere()) setTimeout(endTurn, 600);
                else if (gameState.currentPlayer === 'black') setTimeout(makeAIMove, 600);
                else updateUI();
            };
        }

        function executeMoveLogic(from, to, dist) {
            if (from === 'bar') gameState.bar[gameState.currentPlayer]--;
            else { gameState.points[from].count--; if (gameState.points[from].count === 0) delete gameState.points[from]; }
            
            if (to < 1 || to > 24) { gameState.off[gameState.currentPlayer]++; }
            else {
                if (gameState.points[to] && gameState.points[to].color !== gameState.currentPlayer) {
                    gameState.bar[gameState.currentPlayer === 'white' ? 'black' : 'white']++;
                    gameState.points[to] = { count: 1, color: gameState.currentPlayer };
                } else {
                    if (!gameState.points[to]) gameState.points[to] = { count: 0, color: gameState.currentPlayer };
                    gameState.points[to].count++;
                }
            }
            gameState.currentRoll.splice(gameState.currentRoll.indexOf(dist), 1);
        }

        function endTurn() {
            if (gameState.off.white === 15 || gameState.off.black === 15) { alert("GAME OVER! " + (gameState.off.white === 15 ? "PINKY" : "BRAIN") + " holt die Weltherrschaft!"); location.reload(); return; }
            gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
            gameState.diceRolled = false; gameState.currentRoll = []; gameState.selectedPoint = null;
            renderBoard(); updateUI();
            if(gameState.currentPlayer === 'black') checkAITurn();
        }

        function updateUI() {
            const isW = gameState.currentPlayer === 'white';
            const nameEl = document.getElementById('p-name');
            nameEl.innerText = isW ? 'PINKY' : 'BRAIN';
            nameEl.style.color = isW ? 'var(--player-1)' : 'var(--player-2)';
            document.getElementById('p-moves').innerText = gameState.diceRolled ? `Moves: ${gameState.currentRoll.join(', ')}` : "Roll the dice";
            renderBar('white'); renderBar('black'); renderOff();
        }

        function renderBar(color) {
            const el = document.getElementById(`bar-${color}`); el.innerHTML = '';
            for (let i = 0; i < gameState.bar[color]; i++) {
                const c = document.createElement('div'); c.className = `checker ${color}-checker`;
                if (gameState.selectedPoint === 'bar' && gameState.currentPlayer === color && i === gameState.bar[color]-1) c.classList.add('selected');
                el.appendChild(c);
            }
        }

        function renderOff() {
            ['white', 'black'].forEach(c => {
                const el = document.getElementById(`off-${c}`); el.innerHTML = '';
                for (let i = 0; i < gameState.off[c]; i++) {
                    const ch = document.createElement('div'); ch.className = 'off-checker';
                    ch.style.backgroundColor = c === 'white' ? 'var(--player-1)' : 'var(--player-2)';
                    el.appendChild(ch);
                }
            });
        }

        function renderBoard() {
            const layout = [{ id: 'q-lower-right', range: [6, 5, 4, 3, 2, 1] }, { id: 'q-lower-left', range: [12, 11, 10, 9, 8, 7] }, { id: 'q-upper-left', range: [13, 14, 15, 16, 17, 18] }, { id: 'q-upper-right', range: [19, 20, 21, 22, 23, 24] }];
            layout.forEach(q => {
                const el = document.getElementById(q.id); el.innerHTML = '';
                q.range.forEach(num => {
                    const p = document.createElement('div'); p.className = 'point'; p.setAttribute('data-point', num);
                    p.onclick = () => handlePointClick(num);
                    const tri = document.createElement('div'); tri.className = `triangle-shape ${num % 2 === 0 ? 'color-turquoise' : 'color-pink'}`;
                    const stack = document.createElement('div'); stack.className = 'checker-stack';
                    stack.appendChild(document.createElement('div')).className = 'edge-spacer';
                    if (gameState.points[num]) {
                        for (let i = 0; i < gameState.points[num].count; i++) {
                            const c = document.createElement('div'); c.className = `checker ${gameState.points[num].color}-checker`;
                            if (gameState.selectedPoint === num && i === gameState.points[num].count - 1) c.classList.add('selected');
                            stack.appendChild(c);
                        }
                    }
                    p.appendChild(tri); p.appendChild(stack); el.appendChild(p);
                });
            });
            renderBar('white'); renderBar('black'); renderOff();
        }

        function checkAITurn() { if (gameState.currentPlayer === 'black' && !gameState.diceRolled && !gameState.isAnimating) setTimeout(rollDice, 1200); }

        async function makeAIMove() {
            if (gameState.currentPlayer !== 'black' || gameState.isAnimating || !gameState.diceRolled) return;
            if (gameState.currentRoll.length === 0) { endTurn(); return; }
            const rolls = [...gameState.currentRoll].sort((a, b) => b - a);
            let possibleMoves = [];
            if (gameState.bar.black > 0) { for (let r of rolls) if (isMoveLegal('bar', r, r)) possibleMoves.push({ from: 'bar', to: r, dist: r, weight: 100 }); }
            else {
                for (let p in gameState.points) {
                    if (gameState.points[p].color === 'black') {
                        for (let r of rolls) {
                            const to = parseInt(p) + r;
                            if (isMoveLegal(p, to, r)) {
                                let weight = to; if (to > 24) weight += 100;
                                if (gameState.points[to] && gameState.points[to].count === 1) weight += 50;
                                possibleMoves.push({ from: p, to: to, dist: r, weight: weight });
                            }
                        }
                    }
                }
            }
            if (possibleMoves.length > 0) {
                possibleMoves.sort((a, b) => b.weight - a.weight);
                await animateAndMove(possibleMoves[0].from, possibleMoves[0].to, possibleMoves[0].dist);
            } else setTimeout(endTurn, 500);
        }

        renderBoard(); drawDie('die1', 1); drawDie('die2', 2);
    </script>
</body>
</html>
